[{"uri":"https://plotly.github.io/Dash.NET/index.html","title":"Dash.NET\r\n","content":"# Dash.NET\r\n\r\n![](img/logo_title.svg)\r\n\r\nDash.NET is a .NET interface to [Dash](https://plotly.com/dash/) - the most downloaded framework for building ML \u0026amp; data science web apps - written in F#. Built on top of Plotly.js, React and asp.netcore (via Giraffe), Dash.NET ties modern UI elements like dropdowns, sliders, and graphs directly to your analytical .NET code.\r\n\r\nThis library is under heavy development. Things might break. However, Dash.NET has a stable core and has already been used for non trivial applications ([example1](https://github.com/CSBiology/TMEA), [example2](https://github.com/TRR175/ExploreKinetics)). The current development goal is to implement all targets set in the [beta roadmap](https://github.com/plotly/Dash.NET/issues/4), where you can also see a summary of the state of the project.\r\n\r\nThe documentation is WIP as well.\r\n\r\n# Table of contents\r\n\r\n\u003C!-- TOC --\u003E\r\n\r\n- [Installation](#installation)\r\n- [Usage](#usage)\r\n    - [Basic application](#basic-application)\r\n    - [Referencing content](#referencing-content)\r\n    - [Dash Core components (DCC)](#dash-core-components-dcc)\r\n    - [callbacks](#callbacks)\r\n        - [single output](#single-output)\r\n        - [using Dash.NET operators](#using-dashnet-operators)\r\n        - [multiple outputs](#multiple-outputs)\r\n        - [Recommendations for callbacks (especially multi output callbacks)](#recommendations-for-callbacks-especially-multi-output-callbacks)\r\n    - [Using state](#using-state)\r\n    - [build](#build)\r\n    - [docs](#docs)\r\n    - [Run the dev server application](#run-the-dev-server-application)\r\n\r\n\u003C!-- /TOC --\u003E\r\n\r\n## Installation\r\n\r\nGet the latest preview package via nuget: [![](https://img.shields.io/nuget/vpre/Dash.NET)](https://www.nuget.org/packages/Dash.NET/)\r\n\r\nUse the \u0060dotnet new\u0060 template: \r\n\r\n\u0060dotnet new -i Dash.NET.Template::*\u0060 \r\n\r\n(watch out, this template might not use the latest Dash.NET package, take a look at the referenced version and update if needed )\r\n\r\n\r\n## Usage\r\n\r\nIn Dash.NET, everything is basically about constructing a \u0060DashApp\u0060 that holds all parts of your dash application, such as:\r\n-  the \u0060Layout\u0060, which holds the UI components of your application\r\n- \u0060Callbacks\u0060 that handle how different components in your \u0060Layout\u0060 interact with each other\r\n- Various server and renderer configurations via \u0060DashConfig\u0060\r\n- The \u0060IndexView\u0060 template that controls the html scaffold that holds the rendered application.\r\n\r\nThe most simple (and boring) Dash.NET application looks like this:\r\n\r\n\u0060\u0060\u0060fsharp\r\nopen Dash.NET\r\n\r\nlet myApp = DashApp.initDefault()\r\n\u0060\u0060\u0060\r\n\r\nWhich creates a \u0060DashApp\u0060 with all fields initialized with empty defaults. The http handler for a \u0060DashApp\u0060 can be accessed via the \u0060DashApp.toHttpHandler\u0060 function to plug it into your aps.netcore application configuration function via \u0060UseGiraffe\u0060 (for more info, check out Giraffe docs or take a look at the [dev project in this repo](https://github.com/plotly/Dash.NET/blob/dev/dev/Program.fs#L104))\r\n\r\n### Basic application\r\n\r\nTo get actual content into the default application, it needs a \u0060Layout\u0060. \u0060Layout\u0060s can be created via Dash.NET\u0027s DSL for html components, where the first function parameter is always a list of properties (e.g. for setting css classes), and the second a list of children.\r\n\r\n\u0060\u0060\u0060fsharp\r\nopen Dash.NET.HTML\r\n\r\n//Will create the following html:\r\n//\u003Cdiv\u003E\r\n//  \u003Ch1\u003E\u0022Hello world from Dash.NET!\u0022\u003C/h1\u003E\r\n//\u003C/div\u003E\r\n//\r\nlet myLayout = \r\n    Div.div [] [\r\n        H1.h1 [] [str \u0022Hello world from Dash.NET!\u0022]\r\n    ]\r\nlet test = \r\n    DashApp.initDefault()\r\n    |\u003E DashApp.withLayout myLayout\r\n\u0060\u0060\u0060\r\n\r\n![](img/hello-world.png)\r\n\r\n---\r\n\r\n\u003Cbr\u003E\r\n\r\n### Referencing content\r\n\r\nYou can include internal and external stylesheets and scripts via \u0060DashApp.appendCSSLinks\u0060 and \u0060DashApp.appendScripts\u0060:\r\n\r\nLet\u0027s say you have the following \u0060main.css\u0060 file in your wwwroot directory (served from \u0060/main.css\u0060)\r\n\r\n\u0060\u0060\u0060CSS\r\nh1 {\r\n    font-size: 1.5em;\r\n    color: green;\r\n}\r\n\u0060\u0060\u0060\r\n\r\nyou can reference it from your \u0060DashApp\u0060 like this (using the basic example from above):\r\n\r\n\u0060\u0060\u0060fsharp\r\nlet test = \r\n    DashApp.initDefault()\r\n    |\u003E DashApp.withLayout myLayout\r\n    |\u003E DashApp.appendCSSLinks [\u0022main.css\u0022]\r\n\r\n\u0060\u0060\u0060\r\n\r\n![](img/hello-world-green.png)\r\n\r\n---\r\n\r\nIf you want to reference external content (e.g. a CSS framework like [Bulma](https://bulma.io/)), you can do that as well. To use the classes defined there, set the \u0060ClassName\u0060 accordingly:\r\n\r\n\u0060\u0060\u0060fsharp\r\nlet myLayout = \r\n    Div.div [] [\r\n        H1.h1 [ClassName \u0022title is-1\u0022] [str \u0022Hello world from Dash.NET!\u0022]\r\n    ]\r\n\r\n\r\nlet test = \r\n    DashApp.initDefault()\r\n    |\u003E DashApp.withLayout myLayout\r\n    |\u003E DashApp.appendCSSLinks [\r\n        \u0022https://cdnjs.cloudflare.com/ajax/libs/bulma/0.9.1/css/bulma.min.css\u0022\r\n    ]\r\n\u0060\u0060\u0060\r\n\r\n![](img/hello-world-bulma.png)\r\n\r\n---\r\n\r\n### Dash Core components (DCC)\r\n\r\nYou can also use most dash core components. The following example uses the Plotly.NET to create a plotly graph component. Note that all core components must have a nunique id, and therefore have the mandatory id parameter:\r\n\r\n\u0060\u0060\u0060fsharp\r\nopen Dash.NET.HTML\r\nopen Dash.NET.DCC\r\nopen Plotly.NET\r\n\r\nlet myGraph = Chart.Line([(1,1);(2,2)])\r\n\r\nlet myLayout = \r\n    Div.div [] [\r\n        H1.h1 [] [str \u0022Hello world from Dash.NET!\u0022]\r\n        H2.h2 [] [str \u0022Take a look at this graph:\u0022]\r\n        Graph.graph \u0022my-ghraph-id\u0022 [Graph.Figure (myGraph |\u003E GenericChart.toFigure)] []\r\n    ]\r\nlet test = \r\n    DashApp.initDefault()\r\n    |\u003E DashApp.withLayout myLayout\r\n\u0060\u0060\u0060\r\n\r\n![](img/hello-graph.png)\r\n\r\n---\r\n\r\n\u003Cbr\u003E\r\n\r\n### callbacks\r\n\r\nCallbacks describe the interactive part of your \u0060DashApp\u0060. \r\n\r\n#### single output\r\n\r\nCallbacks with single outputs describe either a (1 -\u003E 1) or (n -\u003E 1) dependency between components.\r\n\r\nIn the most basic case, you have one input component, which updates one output component (1 -\u003E 1). For both you need to assign the property of the component that will be part of the callback. Additionally, a function is needed that takes the input and returns the output. Lets first define the layout for this example:\r\n\r\n\u0060\u0060\u0060fsharp\r\nopen Dash.NET.HTML\r\nopen HTMLPropTypes\r\nopen Dash.NET.DCC\r\nopen ComponentPropTypes\r\n\r\nlet myLayout = \r\n    Div.div [] [\r\n        H1.h1 [] [str \u0022Hello world from Dash.NET!\u0022]\r\n        H2.h2 [] [str \u0022Tell us something!\u0022]\r\n        Input.input \u0022test-input\u0022 [Input.Type InputType.Text] []\r\n        H2.h2 [Id \u0022test-output\u0022] []\r\n    ]\r\n\u0060\u0060\u0060\r\n\r\nThere are multiple ways of defining callbacks, all of which use the respective \u0060DashApp.singleOut\u0060 overloads for (1 -\u003E 1), as well as (1 -\u003E n) callbacks. \r\n\r\nThe most simple (1 -\u003E 1) callback needs:\r\n- 1 \u0060CallbackInput\u0060, which is a representation of the input component and the property that triggers the callback\r\n- 1 \u0060CallbackOutput\u0060, which is a representation of the output component and the property that will be updated by the callback\r\n- A function taking as many inputs as there are input components (1 in this case) that creates the callback output\r\n\r\n\u0060\u0060\u0060fsharp\r\n// a 1 -\u003E 1 callback\r\nlet testCallback =\r\n    Callback.singleOut(\r\n        CallbackInput.create(\u0022test-input\u0022,\u0022value\u0022)],       // \u003C- Input of the callback is the \u0060value\u0060 property of the component with the id \u0022test-input\u0022\r\n        CallbackOutput.create(\u0022test-output\u0022,\u0022children\u0022),    // \u003C- Output of the callback is the \u0060children\u0060 property of the component with the id \u0022test-output\u0022\r\n        (fun (input:string) -\u003E                              // this function takes a string as input and returns another message.\r\n            sprintf \u0022You said : %s\u0022 input\r\n        )\r\n    )\r\n\u0060\u0060\u0060\r\n\r\n![](/img/callback.gif)\r\n\r\n#### using Dash.NET operators\r\n\r\nWhile above usage of callbacks is the most similar to the original python library, we can leverage the type System of F# to make those calls a little bit safer.\r\n\r\nTo simplify the generation of \u0060CallbackInput\u0060 and \u0060CallbackOutput\u0060, as well as making sure you are updating the right property in the callback handler function, you can use the custom operators provided by Dash.NET:\r\n\r\n- \u0060@.\u0060 defines \u0060CallbackInput\u0060 or \u0060CallbackOutput\u0060 (as well as \u0060CallbackState\u0060, more on that later) in a typesafe way, so you don\u0027t need to write the properties in string from anymore.\r\n\r\n- \u0060=\u003E\u0060 defines a \u0060CallbackResultBinding\u0060, which is the representation of a function result bound to the given output property (this is more valuable when we come to multioutput callbacks later)\r\n\r\nHere is the same simple callback using Dash.NET operators:\r\n\r\n\u0060\u0060\u0060fsharp\r\nopen Dash.NET.Operators\r\n\r\nlet testCallback =\r\n    Callback.singleOut(\r\n        \u0022test-input\u0022 @. Value,       // \u003C- Input of the callback is the \u0060value\u0060property of the component with the id \u0022test-input\u0022, now typesafe\r\n        \u0022test-output\u0022 @. Children,    // \u003C- Output of the callback is the \u0060children\u0060 property of the component with the id \u0022test-output\u0022, now typesafe\r\n        (fun (input:string) -\u003E                              // this function takes a string as input and returns another message, now bound to the output property\r\n            \u0022test-output\u0022 @. Children =\u003E sprintf \u0022You said : %s\u0022 input\r\n        )\r\n    )\r\n\r\n\u0060\u0060\u0060\r\n\r\nIf you don\u0027t like operators, you can still make your callbacks safer using the type safe \u0060create\u0060 overloads and \u0060CallbackResultBinding.create\u0060:\r\n\r\n\u0060\u0060\u0060fsharp\r\nlet testCallback =\r\n    Callback.singleOut(\r\n        CallbackInput.create(\u0022test-input\u0022 ,Value),       // \u003C- Input of the callback is the \u0060value\u0060 property of the component with the id \u0022test-input\u0022\r\n        CallbackOutput.create(\u0022test-output\u0022, Children),    // \u003C- Output of the callback is the \u0060children\u0060 property of the component with the id \u0022test-output\u0022\r\n        (fun (input:string) -\u003E                              // this function takes a string as input and returns another message.\r\n            CallbackResultBinding.bindResult \r\n                (CallbackOutput.create(\u0022test-output\u0022, Children))\r\n                (sprintf \u0022You said : %s\u0022 input)\r\n        )\r\n    )\r\n\u0060\u0060\u0060\r\n\r\n#### multiple outputs\r\n\r\nThe following example shows how to define a (n -\u003E n) multi output callback, again first with the most python-like way, and then in more type safe .NET manner.\r\n\r\nlet\u0027s first define the layout used in this example:\r\n\r\n\u0060\u0060\u0060fsharp\r\nlet testLayout =\r\n\r\n    Div.div [] [\r\n        H1.h1 [] [str \u0022Hello world from Dash.NET!\u0022]\r\n        Input.input \u0022test-input1\u0022 [Input.Type InputType.Number; Input.Value 2.] []\r\n        Input.input \u0022test-input2\u0022 [Input.Type InputType.Number; Input.Value 3.] []\r\n        H2.h2 [] [str \u0022first number times 2 is:\u0022]\r\n        Div.div [Id \u0022test-output1\u0022] []        \r\n        H2.h2 [] [str \u0022first number times squared is:\u0022]\r\n        Div.div [Id \u0022test-output2\u0022] []\r\n        H2.h2 [] [str \u0022second number times 3 is:\u0022]\r\n        Div.div [Id \u0022test-output3\u0022] []\r\n        H2.h2 [] [str \u0022second number squared is:\u0022]\r\n        Div.div [Id \u0022test-output4\u0022] []\r\n    ]\r\n\r\n\u0060\u0060\u0060\r\n\r\nWe will now create a (2 -\u003E 4) callback, where we multiply and square each number.\r\n\r\nTo define multi output callbacks, use \u0060Callback.multiOut\u0060:\r\n\r\n\u0060\u0060\u0060fsharp\r\n\r\nlet multiOutCallbackExample =\r\n    Callback.multiOut(\r\n        [\r\n            CallbackInput.create(\u0022test-input1\u0022, \u0022value\u0022)\r\n            CallbackInput.create(\u0022test-input2\u0022, \u0022value\u0022)\r\n        ],\r\n        [\r\n            CallbackInput.create(\u0022test-output1\u0022, \u0022children\u0022)\r\n            CallbackInput.create(\u0022test-output2\u0022, \u0022children\u0022)            \r\n            CallbackInput.create(\u0022test-output3\u0022, \u0022children\u0022)\r\n            CallbackInput.create(\u0022test-output4\u0022, \u0022children\u0022)\r\n        ],\r\n        (fun (input1:float) (input2:float) -\u003E\r\n            [\r\n               input1 * 2.\r\n               input1 * input1\r\n               input2 * 3.\r\n               input2 * input2\r\n            ]\r\n        )\r\n    )\r\n\u0060\u0060\u0060\r\n\r\n![](img/multi-callback.gif)\r\n\r\n#### Recommendations for callbacks (especially multi output callbacks)\r\n\r\nAs you might already see, multi outputs are a lot trickier to do right this way, mainly due to two problems:\r\n\r\n1. The fact that the output must be an array, where the **position of the result will be mapped to the same position in the \u0060CallbackOutput\u0060 array** opens possibilities for a lot of mixups and bugs, while being hard to debug aswell.\r\n\r\n2. Additionally to 1., **when your outputs must be of different types, you must box all results to keep them in the same collection**, therefore returning an object collection which is even more obstrusive because you loose the descriptive type annotation of the callback, as it will now be something along the lines of \u0060Callback\u003C*A -\u003E seq\u003Cobj\u003E\u003E\u0060\r\n\r\nTo tackle both issues, we recommend your Calllback functions to **always return CallbackResultBindin(s)**, as they can be used internally to be always mapped to the correct output property, and internally box the result aswell. Here is a version of this for the initial example, also using Dash.NET custom operators:\r\n\r\n\u0060\u0060\u0060fsharp\r\nlet multiOutCallbackExample =\r\n    Callback.multiOut(\r\n        [\r\n            \u0022test-input1\u0022 @. Value\r\n            \u0022test-input2\u0022 @. Value\r\n        ],\r\n        [\r\n            \u0022test-output1\u0022 @. Children\r\n            \u0022test-output2\u0022 @. Children          \r\n            \u0022test-output3\u0022 @. Children\r\n            \u0022test-output4\u0022 @. Children\r\n        ],\r\n        (fun (input1:float) (input2:float) -\u003E\r\n            [\r\n               \u0022test-output1\u0022 @. Children =\u003E input1 * 2.\r\n               \u0022test-output3\u0022 @. Children =\u003E input2 * 3.\r\n               \u0022test-output2\u0022 @. Children =\u003E input1 * input1\r\n               \u0022test-output4\u0022 @. Children =\u003E input2 * input2\r\n            ]\r\n        )\r\n    )\r\n\u0060\u0060\u0060\r\n\r\nnote that this callback still maps to the correct output components although the order is intentionally different from the input array.\r\n\r\n---\r\n\r\n### Using state \r\n\r\nUse states as non-triggering input for callbacks. You can use the optional \u0060State\u0060 constructor parameter of \u0060Callback\u0060. Just keep in mind that the state will be used for your callback function parameters _after_ the callback inputs:\r\n\r\n\u0060\u0060\u0060fsharp\r\nlet myLayout = \r\n    Div.div [] [\r\n        H1.h1 [] [str \u0022Hello world from Dash.NET!\u0022]\r\n        H2.h2 [] [str \u0022Tell us something!\u0022]\r\n        Input.input \u0022test-input\u0022 [Input.Type InputType.Text] []\r\n        H3.h3 [] [str \u0022Input below will not trigger the callback\u0022]\r\n        Input.input \u0022test-input-state\u0022 [Input.Type InputType.Text] []\r\n        H2.h2 [Id \u0022test-output\u0022] []\r\n    ]\r\n\r\nlet testCallback =\r\n    Callback.singleOut(\r\n        \u0022test-input\u0022 @. Value,\r\n        \u0022test-output\u0022 @. Children,\r\n        (fun (input:string) (state:string) -\u003E\r\n            \u0022test-output\u0022 @. Children =\u003E (\r\n                sprintf \u0022You said : \u0027%s\u0027 and we added the state: \u0027%s\u0027\u0022 input state)\r\n        ),\r\n        State = [\u0022test-input-state\u0022 @. Value]\r\n    )\r\n\r\nlet test = \r\n    DashApp.initDefault()\r\n    |\u003E DashApp.withLayout myLayout\r\n    |\u003E DashApp.addCallback testCallback\r\n\u0060\u0060\u0060\r\n\r\n![](img/state.gif)\r\n\r\n---\r\n\r\n# Development\r\n\r\n_Note:_ The \u0060release\u0060 and \u0060prerelease\u0060 build targets assume that there is a \u0060NUGET_KEY\u0060 environment variable that contains a valid Nuget.org API key.\r\n\r\n### build\r\n\r\nCheck the [build.fsx file](https://github.com/plotly/Dash.NET/blob/dev/build.fsx) to take a look at the  build targets. Here are some examples:\r\n\r\n\u0060\u0060\u0060shell\r\n# Windows\r\n\r\n# Build only\r\n./build.cmd\r\n\r\n# Full release buildchain: build, test, pack, build the docs, push a git tag, publsih thze nuget package, release the docs\r\n./build.cmd -t release\r\n\r\n# The same for prerelease versions:\r\n./build.cmd -t prerelease\r\n\r\n\r\n# Linux/mac\r\n\r\n# Build only\r\nbuild.sh\r\n\r\n# Full release buildchain: build, test, pack, build the docs, push a git tag, publsih thze nuget package, release the docs\r\nbuild.sh -t release\r\n\r\n# The same for prerelease versions:\r\nbuild.sh -t prerelease\r\n\r\n\u0060\u0060\u0060\r\n\r\n### docs\r\n\r\nThe docs are contained in \u0060.fsx\u0060 and \u0060.md\u0060 files in the \u0060docs\u0060 folder. To develop docs on a local server with hot reload, run the following in the root of the project:\r\n\r\n\u0060\u0060\u0060shell\r\n# Windows\r\n./build.cmd -t watchdocs\r\n\r\n# Linux/mac\r\n./build.sh -t watchdocs\r\n\u0060\u0060\u0060\r\n\r\n### Run the dev server application\r\n\r\nThe dev server is useful to test new components/code. After a successful build \r\nyou can start the dev server application by executing the following command in your terminal:\r\n\r\n\u0060\u0060\u0060\r\ndotnet run -p ./dev/Dash.NET.Dev.fsproj\r\n\u0060\u0060\u0060\r\n\r\nAfter the application has started visit [https://localhost:5001/](https://localhost:5001/) or [http://localhost:5000/](http://localhost:5000/) in your preferred browser."}]